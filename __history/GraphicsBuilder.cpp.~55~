#include "GraphicsBuilder.h"
#include "DrawOrderer.h" // Подключаем заголовок с определением DrawOrderer
#include <algorithm>
#include <cmath>
#include <limits>

GraphicsBuilder::GraphicsBuilder(const std::vector<DrawOrderer::OrderStruct>& source)
	: m_source(source) {
	updateTransformedData();
}

void GraphicsBuilder::setSettings(const DrawSettings& settings) {
    m_settings = settings;
    updateTransformedData();
}

DrawSettings GraphicsBuilder::getSettings() const {
    return m_settings;
}

void GraphicsBuilder::updateTransformedData() {
	m_transformed.clear();
	if(m_source.size() > 0)
	{
		for (const auto& elem : m_source) {
			m_transformed.push_back(transformElement(elem, m_settings.canvasHeight));
		}
	}

}

void GraphicsBuilder::paint(TCanvas* canvas, const TRect& drawArea) {
    if (!canvas) return;

     if(m_transformed.empty()) return;

     // Обновляем данные с учетом высоты канвы
    updateTransformedData();

    // Заливка фона
    canvas->Brush->Color = m_settings.backgroundColor;
    canvas->FillRect(drawArea);

	for (int i=0; i < m_transformed.size(); i++) {
			if(m_transformed[i].Type == 1) {
				canvas->Pen->Color = m_settings.lineColor;
				canvas->MoveTo(m_transformed[i].x1, m_transformed[i].y1);
				canvas->LineTo(m_transformed[i].x2, m_transformed[i].y2);
			}else
			if(m_transformed[i].Type == 2) {
				drawArc(canvas, m_transformed[i]);
			}else
			if(m_transformed[i].Type == 3)
			{
				drawCircle(canvas, m_transformed[i]);
			}
		}

}

void GraphicsBuilder::mouseDown(int x, int y) {
    m_dragging = true;
    m_lastX = x;
    m_lastY = y;
}

void GraphicsBuilder::mouseMove(int x, int y) {
	if(m_transformed.empty()) return;
	if (m_dragging) {
        m_settings.xOffset += (x - m_lastX);
		m_settings.yOffset -= (y - m_lastY); // Инвертируем изменение Y
        m_lastX = x;
        m_lastY = y;
		updateTransformedData();
	}
}

void GraphicsBuilder::mouseUp() {
    m_dragging = false;
}

void GraphicsBuilder::mouseWheel(int delta, int x, int y) {
    double factor = (delta > 0) ? 1.1 : 0.9;
    double newScale = m_settings.scale * factor;

    // Сохраняем мировые координаты точки под курсором
    double worldX = (x - m_settings.xOffset) / m_settings.scale;
    double worldY = (y - m_settings.yOffset) / m_settings.scale;

    // Обновляем смещение для сохранения позиции точки
    m_settings.xOffset = x - worldX * newScale;
    m_settings.yOffset = y - worldY * newScale;
    m_settings.scale = newScale;

    updateTransformedData();
}

void GraphicsBuilder::fitToView(const TRect& drawArea) {
	if (m_source.empty()) return;

	m_settings.drawArea = drawArea; //Запомнили указатель на канву

    double minX = std::numeric_limits<double>::max();
    double maxX = std::numeric_limits<double>::lowest();
    double minY = minX, maxY = maxX;

	for (const auto& elem : m_source) {
        updateBounds(elem, minX, maxX, minY, maxY);
    }

    double width = maxX - minX;
    double height = maxY - minY;

    if (width == 0 || height == 0) return;

    // Рассчет масштаба с отступом 10%
    double scaleX = drawArea.Width() / width * 0.9;
    double scaleY = drawArea.Height() / height * 0.9;
	m_settings.scale = std::min(scaleX, scaleY);
    // Центрирование
    double centerWorldX = (minX + maxX) / 2.0;
    double centerWorldY = (minY + maxY) / 2.0;
	m_settings.xOffset = drawArea.Width() / 2 - centerWorldX * m_settings.scale;
	m_settings.yOffset = drawArea.Height() / 2 + centerWorldY * m_settings.scale;

    updateTransformedData(drawArea.Height());
}

void GraphicsBuilder::updateBounds(const DrawOrderer::OrderStruct& elem,
                                 double& minX, double& maxX,
                                 double& minY, double& maxY) {
    auto expand = [&](double x, double y) {
        minX = std::min(minX, x);
        maxX = std::max(maxX, x);
        minY = std::min(minY, y);
        maxY = std::max(maxY, y);
    };

	expand(elem.x1, elem.y1);
	expand(elem.x2, elem.y2);

	if (elem.Type == 2 || elem.Type == 3) {
		// Для дуг и окружностей учитываем центр и радиус
		// Проверка корректности данных
        if (!std::isfinite(elem.x1) || !std::isfinite(elem.y1) ||
            !std::isfinite(elem.i) || !std::isfinite(elem.j)) {
            return;
        }

        double dx1 = elem.x1 - elem.i;
        double dy1 = elem.y1 - elem.j;

        // Устойчивое вычисление радиуса
        double maxVal = std::max(std::abs(dx1), std::abs(dy1));
        if (maxVal > 0) {
            double dxNorm = dx1 / maxVal;
            double dyNorm = dy1 / maxVal;
            double radius = maxVal * std::sqrt(dxNorm*dxNorm + dyNorm*dyNorm);

            if (std::isfinite(radius)) {
                const double MAX_RADIUS = 1e6;
                if (radius > MAX_RADIUS) {
                    radius = MAX_RADIUS;
                }
                expand(elem.i - radius, elem.j - radius);
                expand(elem.i + radius, elem.j + radius);
            }
        } else {
            // Точки совпадают - радиус нулевой
            expand(elem.i, elem.j);
		}
	}
}

DrawToolLine GraphicsBuilder::transformElement(const DrawOrderer::OrderStruct& elem, int canvasHeight) const {
    return {
        worldToScreenX(elem.x1),
		worldToScreenY(elem.y1, canvasHeight),
		worldToScreenX(elem.x2),
		worldToScreenY(elem.y2, canvasHeight),
	   //	elem.i,
	   // elem.j,
		worldToScale(elem.i),
		worldToScale(elem.j),
        elem.Type
    };
}

double GraphicsBuilder::worldToScreenX(double worldX) const {
    return worldX * m_settings.scale + m_settings.xOffset;
}

double GraphicsBuilder::worldToScreenY(double worldY, int canvasHeight) const {
    return canvasHeight - (worldY * m_settings.scale + m_settings.yOffset);
}

double GraphicsBuilder::worldToScale(double worldX) const {
	return worldX * m_settings.scale;
}

void GraphicsBuilder::drawArc(TCanvas* canvas, DrawToolLine& arc) const {
    if (!canvas) return;

    canvas->Pen->Color = m_settings.arcColor;
	double dxCenter = arc.i;
	double dyCenter = arc.j;
	double radius = std::sqrt(dxCenter*dxCenter + dyCenter*dyCenter);

	TRect rect(
		static_cast<int>(arc.x1 + arc.i - radius),
		static_cast<int>(arc.y1 + arc.j - radius),
		static_cast<int>(arc.x1 + arc.i + radius),
		static_cast<int>(arc.y1 + arc.j + radius)
    );
	//Возможно нужно будет расширить с провркой направления
	canvas->Arc(
        rect.Left, rect.Top, rect.Right, rect.Bottom,
		static_cast<int>(arc.x2), static_cast<int>(arc.y2),
		static_cast<int>(arc.x1), static_cast<int>(arc.y1)
    );
}

void GraphicsBuilder::drawCircle(TCanvas* canvas, DrawToolLine& circle) const {
	if (!canvas) return;

	canvas->Pen->Color = m_settings.circleColor;
	double dx = circle.i;
	double dy = circle.j;
	double radius = std::sqrt(dx*dx + dy*dy);

	canvas->Ellipse(
		static_cast<int>(circle.x1 + circle.i - radius),
		static_cast<int>(circle.y1 + circle.j - radius),
		static_cast<int>(circle.x1 + circle.i + radius),
		static_cast<int>(circle.y1 + circle.j + radius)
	);
}
