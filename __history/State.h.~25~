#ifndef STATE_H
#define STATE_H

#include <vector>
#include <map>

/* 20.07.2025    8romeo8@list.ru       (+79780592624)
   Класс для хранения состояния машины и переходов между состояниями.
   Описание состояний:

   DefaultState - Состояние после загрузки и парсинга dxf файла.
   PointSelectionState - Состояние выбора первичной точки старта программы.
   PathSelectionState - Состояние выбора траектории движения машины.
   EquidistantSelectionState - Состояние выбора направления смещения траектории.
   PathGenerationState - Состояние формирования итоговой траектории движения.
   ReadyToStartState - Траектория сформирована, программа ещё не запущена.
   ZeroCalibrationState - Процедура поиска нулевой точки.
   RunningWithCoolantState - Выполнение программы с включенной СОЖ.
   DryRunningState - Выполнение программы без системы охлаждения.
   PausedState - Временная остановка выполнения программы.
   EndProgramState - Программа завершена.
   RewindState - Движение в обратном направлении.
   RapidMoveState - Позиционирование над выбранной точкой.

   Как использовать

   State machineState;
	if (machineState.setState(PointSelectionState)) {
			// Переход успешен
	} else {
			// Недопустимый переход
	}
*/

enum Status {
    DefaultState,
    PointSelectionState,
    PathSelectionState,
    EquidistantSelectionState,
    PathGenerationState,
    ReadyToStartState,
    ZeroCalibrationState,
    RunningWithCoolantState,
    DryRunningState,
    PausedState,
    EndProgramState,
    RewindState,
    RapidMoveState
};

class State {
private:
    Status currentState;
    std::map<Status, std::vector<Status>> validTransitions;

    void initializeTransitions() {
        // Инициализация допустимых переходов между состояниями
        validTransitions[DefaultState] = {PointSelectionState};
        validTransitions[PointSelectionState] = {PathSelectionState, DefaultState};
        validTransitions[PathSelectionState] = {EquidistantSelectionState, PointSelectionState};
        validTransitions[EquidistantSelectionState] = {PathGenerationState, PathSelectionState};
        validTransitions[PathGenerationState] = {ReadyToStartState, EquidistantSelectionState};
        validTransitions[ReadyToStartState] = {ZeroCalibrationState, RapidMoveState, PathGenerationState};
        validTransitions[ZeroCalibrationState] = {ReadyToStartState, RunningWithCoolantState, DryRunningState};
        validTransitions[RunningWithCoolantState] = {PausedState, EndProgramState, DryRunningState};
        validTransitions[DryRunningState] = {PausedState, EndProgramState, RunningWithCoolantState};
        validTransitions[PausedState] = {RunningWithCoolantState, DryRunningState, ReadyToStartState, EndProgramState};
        validTransitions[EndProgramState] = {ReadyToStartState, DefaultState};
        validTransitions[RewindState] = {PausedState, RunningWithCoolantState, DryRunningState};
        validTransitions[RapidMoveState] = {ReadyToStartState, ZeroCalibrationState};
    }

public:
    State() : currentState(DefaultState) {
        initializeTransitions();
    }

    // Дополнительная отрисовка в зависимости от состояния машины
    void onPaint(TCanvas Canvas) {
        // Реализация отрисовки в зависимости от currentState
    }

    // Возвращает текущий статус
    Status getState() const {
        return currentState;
    }

    // Установка нового состояния с проверкой валидности перехода
    bool setState(Status newState) {
        if (isValidTransition(newState)) {
            currentState = newState;
            return true;
        }
        return false;
    }

    // Проверка возможности перехода в указанное состояние
    bool isValidTransition(Status newState) const {
        auto it = validTransitions.find(currentState);
        if (it != validTransitions.end()) {
            const std::vector<Status>& allowedStates = it->second;
            return std::find(allowedStates.begin(), allowedStates.end(), newState) != allowedStates.end();
        }
        return false;
    }

    // Обработка нажатия мыши (может вызывать переход между состояниями)
    void isMouseDown(int x, int y) {
        // Реализация обработки клика в зависимости от currentState
    }
};

#endif
