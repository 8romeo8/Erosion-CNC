    #include "State.h"

void State::onPaint(TCanvas* Canvas, const TRect& drawArea) {
    //Отрисовываем кнопку выбора точки входа
    if(currentState == DefaultState) {
        int canvasWidth = drawArea.Width();
        int canvasHeight = drawArea.Height();

        // Задаем параметры кнопки
        int buttonWidth = 200;
        int buttonHeight = 50;
        int leftMargin = 50;
        int bottomMargin = 60;

        // Сохраняем область кнопки
        buttonRect = TRect(
            leftMargin,
            canvasHeight - bottomMargin - buttonHeight,
            leftMargin + buttonWidth,
            canvasHeight - bottomMargin
        );

        // Отрисовываем прямоугольник кнопки с учетом наведения
        Canvas->Brush->Color = isHovered ? clBtnHighlight : clBtnFace;
        Canvas->Pen->Color = clBlack;
        Canvas->Rectangle(buttonRect);

        // Настраиваем шрифт
        Canvas->Font->Name = "Tahoma";
        Canvas->Font->Size = 10;
        Canvas->Font->Style = TFontStyles() << fsBold;
        Canvas->Font->Color = clBlack;

        // Вычисляем позицию текста
        int textWidth = Canvas->TextWidth("Указать точку входа");
        int textHeight = Canvas->TextHeight("Указать точку входа");
        int textX = buttonRect.Left + (buttonWidth - textWidth) / 2;
        int textY = buttonRect.Top + (buttonHeight - textHeight) / 2;

        Canvas->TextOut(textX, textY, "Указать точку входа");
    }
}

    // Возвращает текущий статус
	Status State::getState() const {
		return currentState;
    }

	// Установка нового состояния с проверкой валидности перехода
	bool State::setState(Status newState) {
        if (isValidTransition(newState)) {
            currentState = newState;
            return true;
        }
        return false;
    }

    // Проверка возможности перехода в указанное состояние
	bool State::isValidTransition(Status newState) const {
        auto it = validTransitions.find(currentState);
        if (it != validTransitions.end()) {
            const std::vector<Status>& allowedStates = it->second;
            return std::find(allowedStates.begin(), allowedStates.end(), newState) != allowedStates.end();
        }
        return false;
    }

void State::isMouseDown(int x, int y) {
    if(currentState == DefaultState && buttonRect.Contains(TPoint(x, y))) {
        // Обработка нажатия на кнопку
		currentState = PointSelectionState;
		isHovered = false;
    }
}

void State::isMouseMove(int x, int y) {
    if(currentState == DefaultState) {
        // Проверяем, находится ли курсор над кнопкой
        bool nowHovered = buttonRect.Contains(TPoint(x, y));

        // Если состояние изменилось - нужно перерисовать
        if(nowHovered != isHovered) {
            isHovered = nowHovered;
            // Вызовите здесь перерисовку родительского окна
            // Например: ParentControl->Invalidate();
        }
    }
}

const std::map<Status, uint16_t> State::stateButtonMasks = {
    {DefaultState,
        State::BTN_LOAD_FILE},

    {PointSelectionState,
        State::BTN_LOAD_FILE},

	{PathSelectionState,
        State::BTN_ZERO | State::BTN_START | State::BTN_ON_OFF_SOJ},

	{EquidistantSelectionState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

	{PathGenerationState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

	{ReadyToStartState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

	{ZeroCalibrationState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

	{RunningWithCoolantState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

   {DryRunningState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

   {PausedState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

   {EndProgramState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

   {RewindState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ},

   {RapidMoveState,
		State::BTN_STOP | State::BTN_ON_OFF_SOJ}
};


