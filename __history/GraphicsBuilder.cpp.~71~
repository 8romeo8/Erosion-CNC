#include "GraphicsBuilder.h"
#include "DrawOrderer.h" // Подключаем заголовок с определением DrawOrderer
#include <algorithm>
#include <cmath>
#include <limits>

GraphicsBuilder::GraphicsBuilder(const std::vector<DrawOrderer::OrderStruct>& source)
	: m_source(source) {
	updateTransformedData();
}

void GraphicsBuilder::setSettings(const DrawSettings& settings) {
    m_settings = settings;
    updateTransformedData();
}

DrawSettings GraphicsBuilder::getSettings() const {
    return m_settings;
}

void GraphicsBuilder::updateTransformedData() {
	m_transformed.clear();
	if(m_source.size() > 0)
	{
		for (const auto& elem : m_source) {
			m_transformed.push_back(transformElement(elem, m_settings.drawArea.Height()));
		}
	}

}

void GraphicsBuilder::mouseDown(int x, int y) {
    m_dragging = true;
    m_lastX = x;
	m_lastY = y;

	clearSelection();
    findElementsAt(x, y);
}

void GraphicsBuilder::mouseMove(int x, int y) {
	if(m_transformed.empty()) return;
	if (m_dragging) {
        m_settings.xOffset += (x - m_lastX);
		m_settings.yOffset -= (y - m_lastY); // Инвертируем изменение Y
        m_lastX = x;
        m_lastY = y;
		updateTransformedData();
	}
}

void GraphicsBuilder::mouseUp() {
    m_dragging = false;
}

void GraphicsBuilder::mouseWheel(int delta, int x, int y) {
    double factor = (delta > 0) ? 1.1 : 0.9;
    double newScale = m_settings.scale * factor;

    // Сохраняем мировые координаты точки под курсором
    double worldX = (x - m_settings.xOffset) / m_settings.scale;
    double worldY = (y - m_settings.yOffset) / m_settings.scale;

    // Обновляем смещение для сохранения позиции точки
    m_settings.xOffset = x - worldX * newScale;
    m_settings.yOffset = y - worldY * newScale;
    m_settings.scale = newScale;

    updateTransformedData();
}

void GraphicsBuilder::fitToView(const TRect& drawArea) {
	if (m_source.empty()) return;

	m_settings.drawArea = drawArea; //Запомнили указатель на канву

    double minX = std::numeric_limits<double>::max();
    double maxX = std::numeric_limits<double>::lowest();
    double minY = minX, maxY = maxX;

	for (const auto& elem : m_source) {
        updateBounds(elem, minX, maxX, minY, maxY);
    }

    double width = maxX - minX;
    double height = maxY - minY;

    if (width == 0 || height == 0) return;

    // Рассчет масштаба с отступом 10%
    double scaleX = drawArea.Width() / width * 0.9;
    double scaleY = drawArea.Height() / height * 0.9;
	m_settings.scale = std::min(scaleX, scaleY);
    // Центрирование
    double centerWorldX = (minX + maxX) / 2.0;
    double centerWorldY = (minY + maxY) / 2.0;
	m_settings.xOffset = drawArea.Width() / 2 - centerWorldX * m_settings.scale;
	m_settings.yOffset = drawArea.Height() / 2 + centerWorldY * m_settings.scale;

    updateTransformedData();
}

void GraphicsBuilder::updateBounds(const DrawOrderer::OrderStruct& elem,
                                 double& minX, double& maxX,
                                 double& minY, double& maxY) {
    auto expand = [&](double x, double y) {
        minX = std::min(minX, x);
        maxX = std::max(maxX, x);
        minY = std::min(minY, y);
        maxY = std::max(maxY, y);
    };

	expand(elem.x1, elem.y1);
	expand(elem.x2, elem.y2);

	if (elem.Type == 2 || elem.Type == 3) {
		// Для дуг и окружностей учитываем центр и радиус
		// Проверка корректности данных
        if (!std::isfinite(elem.x1) || !std::isfinite(elem.y1) ||
            !std::isfinite(elem.i) || !std::isfinite(elem.j)) {
            return;
        }

        double dx1 = elem.x1 - elem.i;
        double dy1 = elem.y1 - elem.j;

        // Устойчивое вычисление радиуса
        double maxVal = std::max(std::abs(dx1), std::abs(dy1));
        if (maxVal > 0) {
            double dxNorm = dx1 / maxVal;
            double dyNorm = dy1 / maxVal;
            double radius = maxVal * std::sqrt(dxNorm*dxNorm + dyNorm*dyNorm);

            if (std::isfinite(radius)) {
                const double MAX_RADIUS = 1e6;
                if (radius > MAX_RADIUS) {
                    radius = MAX_RADIUS;
                }
                expand(elem.i - radius, elem.j - radius);
                expand(elem.i + radius, elem.j + radius);
            }
        } else {
            // Точки совпадают - радиус нулевой
            expand(elem.i, elem.j);
		}
	}
}

DrawToolLine GraphicsBuilder::transformElement(const DrawOrderer::OrderStruct& elem, int canvasHeight) const {
    return {
        worldToScreenX(elem.x1),
		worldToScreenY(elem.y1, canvasHeight),
		worldToScreenX(elem.x2),
		worldToScreenY(elem.y2, canvasHeight),
		worldToScale(elem.i),
		worldToScale(elem.j),
        elem.Type
    };
}

double GraphicsBuilder::worldToScreenX(double worldX) const {
    return worldX * m_settings.scale + m_settings.xOffset;
}

double GraphicsBuilder::worldToScreenY(double worldY, int canvasHeight) const {
    return canvasHeight - (worldY * m_settings.scale + m_settings.yOffset);
}

double GraphicsBuilder::worldToScale(double worldX) const {
	return worldX * m_settings.scale;
}

void GraphicsBuilder::drawArc(TCanvas* canvas, DrawToolLine& arc) const {
    if (!canvas) return;

    canvas->Pen->Color = m_settings.arcColor;
	double dxCenter = arc.i;
	double dyCenter = arc.j;
	double radius = std::sqrt(dxCenter*dxCenter + dyCenter*dyCenter);

	TRect rect(
		static_cast<int>(arc.x1 + arc.i - radius),
		static_cast<int>(arc.y1 - arc.j - radius),
		static_cast<int>(arc.x1 + arc.i + radius),
		static_cast<int>(arc.y1 - arc.j + radius)
    );
	//Возможно нужно будет расширить с провркой направления
	canvas->Arc(
		rect.Left, rect.Top, rect.Right, rect.Bottom,
		static_cast<int>(arc.x1), static_cast<int>(arc.y1),
		static_cast<int>(arc.x2), static_cast<int>(arc.y2)
    );
}

void GraphicsBuilder::drawCircle(TCanvas* canvas, DrawToolLine& circle) const {
	if (!canvas) return;

	canvas->Pen->Color = m_settings.circleColor;
	double dx = circle.i;
	double dy = circle.j;
	double radius = std::sqrt(dx*dx + dy*dy);

	canvas->Ellipse(
		static_cast<int>(circle.x1 + circle.i - radius),
		static_cast<int>(circle.y1 + circle.j - radius),
		static_cast<int>(circle.x1 + circle.i + radius),
		static_cast<int>(circle.y1 + circle.j + radius)
	);
}

// Методы нахождения линии под мышкой

void GraphicsBuilder::selectElement(int index) {
    m_selectedIndices.insert(index);
}

void GraphicsBuilder::deselectElement(int index) {
    m_selectedIndices.erase(index);
}

void GraphicsBuilder::clearSelection() {
    m_selectedIndices.clear();
}

const std::set<int>& GraphicsBuilder::getSelectedIndices() const {
    return m_selectedIndices;
}

// Преобразование экранных координат в мировые
double GraphicsBuilder::screenToWorldX(int screenX) const {
    return (screenX - m_settings.xOffset) / m_settings.scale;
}

double GraphicsBuilder::screenToWorldY(int screenY) const {
    int canvasHeight = m_settings.drawArea.Height();
    return (canvasHeight - screenY - m_settings.yOffset) / m_settings.scale;
}

// Проверка попадания точки на элемент
bool GraphicsBuilder::isPointOnElement(int index, int screenX, int screenY, double tolerance) const {
    if (index < 0 || index >= static_cast<int>(m_source.size()))
        return false;

    const auto& elem = m_source[index];
    double worldX = screenToWorldX(screenX);
    double worldY = screenToWorldY(screenY);
	double tolWorld = tolerance / m_settings.scale;

	switch (elem.Type) {
        case 1: { // Линия
            // Вычисляем расстояние от точки до отрезка
            double A = worldX - elem.x1;
            double B = worldY - elem.y1;
            double C = elem.x2 - elem.x1;
            double D = elem.y2 - elem.y1;

            double dot = A * C + B * D;
            double len_sq = C * C + D * D;
            double param = (len_sq != 0) ? dot / len_sq : -1;

            double xx, yy;

            if (param < 0) {
                xx = elem.x1;
                yy = elem.y1;
            } else if (param > 1) {
                xx = elem.x2;
                yy = elem.y2;
            } else {
                xx = elem.x1 + param * C;
                yy = elem.y1 + param * D;
            }

            double dx = worldX - xx;
            double dy = worldY - yy;
            return (dx * dx + dy * dy) <= (tolWorld * tolWorld);
        }
		case 3: { // Окружность
            double cx = elem.x1 + elem.i;
            double cy = elem.y1 + elem.j;
            double radius = std::sqrt(elem.i * elem.i + elem.j * elem.j);
            double dist = std::sqrt(
                (worldX - cx) * (worldX - cx) +
                (worldY - cy) * (worldY - cy)
            );
            return std::abs(dist - radius) <= tolWorld;
        }
		case 2: { // Дуга
            // Вычисляем центр и радиус
            double cx = elem.x1 + elem.i;
            double cy = elem.y1 + elem.j;
            double radius = std::sqrt(elem.i * elem.i + elem.j * elem.j);
            double dx = worldX - cx;
            double dy = worldY - cy;
            double dist = std::sqrt(dx*dx + dy*dy);

            // Проверка расстояния до центра
            if (std::abs(dist - radius) > tolWorld) {
                return false;
            }

            // Вычисляем углы в радианах
            auto calcAngle = [](double dx, double dy) {
                double angle = std::atan2(dy, dx);
                return angle < 0 ? angle + 2*M_PI : angle;
            };

            // Углы начальной, конечной и проверяемой точек
            double start_angle = calcAngle(elem.x1 - cx, elem.y1 - cy);
            double end_angle = calcAngle(elem.x2 - cx, elem.y2 - cy);
            double point_angle = calcAngle(dx, dy);

            // Проверка попадания в угловой сектор (против часовой стрелки)
            if (start_angle <= end_angle) {
                return (point_angle >= start_angle && point_angle <= end_angle);
            } else {
                return point_angle >= start_angle || point_angle <= end_angle;
            }
        }
        default:
            return false;
    }
}

// Поиск элементов под курсором
void GraphicsBuilder::findElementsAt(int screenX, int screenY, double tolerance) {
	for (int i = 0; i < static_cast<int>(m_source.size()); ++i) {
		if (isPointOnElement(i, screenX, screenY, tolerance)) {
			selectElement(i);
        }
    }
}

// Отрисовка с выделением выбранных элементов
void GraphicsBuilder::paint(TCanvas* canvas, const TRect& drawArea) {
    if (!canvas) return;

    // Обновляем область рисования
    m_settings.drawArea = drawArea;

    if (m_source.empty()) return;

    // Заливка фона
    canvas->Brush->Color = m_settings.backgroundColor;
    canvas->FillRect(drawArea);

    // Обновляем трансформированные данные
    updateTransformedData();

    // Цвета по умолчанию
    TColor defaultLineColor = m_settings.lineColor;
    TColor defaultArcColor = m_settings.arcColor;
    TColor defaultCircleColor = m_settings.circleColor;

    for (int i = 0; i < static_cast<int>(m_transformed.size()); i++) {
        // Если элемент выбран, меняем цвет
        if (m_selectedIndices.find(i) != m_selectedIndices.end()) {
            canvas->Pen->Color = clRed;  // Цвет выделения
            canvas->Pen->Width = 2;      // Толщина линии для выделения
        } else {
            // Возвращаем стандартные настройки
            canvas->Pen->Width = 1;
            switch (m_transformed[i].Type) {
                case 1: canvas->Pen->Color = defaultLineColor; break;
                case 2: canvas->Pen->Color = defaultArcColor; break;
                case 3: canvas->Pen->Color = defaultCircleColor; break;
            }
        }

        // Отрисовка элемента
        if (m_transformed[i].Type == 1) {
            canvas->MoveTo(m_transformed[i].x1, m_transformed[i].y1);
            canvas->LineTo(m_transformed[i].x2, m_transformed[i].y2);
        } else if (m_transformed[i].Type == 2) {
            drawArc(canvas, m_transformed[i]);
        } else if (m_transformed[i].Type == 3) {
            drawCircle(canvas, m_transformed[i]);
        }
    }
}

///////////////////////////////////


// Вспомогательная функция для сравнения double
bool almostEqual(double a, double b, double eps = 1e-5) {
    return std::abs(a - b) < eps;
}

// Поиск ближайшей точки
GraphicsBuilder::FoundPoint GraphicsBuilder::findClosestPoint(int screenX, int screenY, double tolerance) const {
    FoundPoint result;
    double minDistance = std::numeric_limits<double>::max();
    const double tol = tolerance / m_settings.scale;

    for (size_t i = 0; i < m_source.size(); ++i) {
        const auto& elem = m_source[i];
        double worldX = screenToWorldX(screenX);
        double worldY = screenToWorldY(screenY);

        // Проверка точек начала и конца
        auto checkPoint = [&](double x, double y, int pointType) {
            double dist = std::hypot(worldX - x, worldY - y);
            if (dist < minDistance && dist <= tol) {
                minDistance = dist;
                result = {static_cast<int>(i), pointType, x, y, true};
            }
        };

        // Для всех элементов проверяем начальную и конечную точки
        checkPoint(elem.x1, elem.y1, 0);
        checkPoint(elem.x2, elem.y2, 1);

        // Для дуг и окружностей проверяем центр
        if (elem.Type == 2 || elem.Type == 3) {
            double centerX = elem.x1 + elem.i;
            double centerY = elem.y1 + elem.j;
            checkPoint(centerX, centerY, 2);
        }
    }
    return result;
}

// Построение графа линий
void GraphicsBuilder::buildLineGraph() {
    m_lineGraph.clear();

    for (size_t i = 0; i < m_source.size(); ++i) {
        const auto& elem = m_source[i];
        if (elem.Type != 1) continue; // Только линии

        auto key1 = std::make_pair(elem.x1, elem.y1);
        auto key2 = std::make_pair(elem.x2, elem.y2);

        m_lineGraph[key1].push_back(i);
        m_lineGraph[key2].push_back(i);
    }
}

const std::map<std::pair<double, double>, std::vector<int>>& GraphicsBuilder::getGraph() const {
    return m_lineGraph;
}

// Реализация состояний
void DefaultState::mouseDown(GraphicsBuilder* builder, int x, int y) {
    builder->clearSelection();
    builder->findElementsAt(x, y);
}

void DefaultState::mouseMove(GraphicsBuilder* builder, int x, int y) {
    if (builder->m_dragging) {
        builder->m_settings.xOffset += (x - builder->m_lastX);
        builder->m_settings.yOffset -= (y - builder->m_lastY);
        builder->m_lastX = x;
        builder->m_lastY = y;
        builder->updateTransformedData();
    }
}

void DefaultState::mouseUp(GraphicsBuilder* builder) {
    builder->m_dragging = false;
}

void DefaultState::paint(GraphicsBuilder* builder, TCanvas* canvas) {
    // Стандартная отрисовка
    builder->paint(canvas, builder->m_settings.drawArea);
}

// PointSelectionState
void PointSelectionState::onEnterState(GraphicsBuilder* builder) {
    builder->m_highlightedPoint = GraphicsBuilder::FoundPoint();
    builder->m_currentPoint = GraphicsBuilder::FoundPoint();
}

void PointSelectionState::onExitState(GraphicsBuilder* builder) {
    builder->m_highlightedPoint = GraphicsBuilder::FoundPoint();
}

void PointSelectionState::mouseMove(GraphicsBuilder* builder, int x, int y) {
    builder->m_highlightedPoint = builder->findClosestPoint(x, y);
}

void PointSelectionState::mouseDown(GraphicsBuilder* builder, int x, int y) {
    auto point = builder->findClosestPoint(x, y);
    if (point.valid) {
        builder->m_currentPoint = point;
        if (builder->m_pointSelectionCallback) {
            builder->m_pointSelectionCallback(point);
        }
        builder->returnToDefaultState();
    }
}

void PointSelectionState::mouseUp(GraphicsBuilder* builder) {}

void PointSelectionState::paint(GraphicsBuilder* builder, TCanvas* canvas) {
    // Стандартная отрисовка
    builder->paint(canvas, builder->m_settings.drawArea);

    // Отрисовка подсвеченной точки
    if (builder->m_highlightedPoint.valid) {
        double screenX = builder->worldToScreenX(builder->m_highlightedPoint.worldX);
        double screenY = builder->worldToScreenY(
            builder->m_highlightedPoint.worldY,
            builder->m_settings.drawArea.Height()
        );

        canvas->Pen->Color = builder->m_settings.highlightColor;
        canvas->Brush->Style = bsClear;
        canvas->Ellipse(
            static_cast<int>(screenX - 8),
            static_cast<int>(screenY - 8),
            static_cast<int>(screenX + 8),
            static_cast<int>(screenY + 8)
        );
    }
}

// PathSelectionState
void PathSelectionState::onEnterState(GraphicsBuilder* builder) {
    builder->buildLineGraph();
    // Дополнительная инициализация для построения пути
}

void PathSelectionState::mouseDown(GraphicsBuilder* builder, int x, int y) {
    // Реализация выбора пути
}

void PathSelectionState::mouseMove(GraphicsBuilder* builder, int x, int y) {
    // Подсветка текущего пути
}

void PathSelectionState::mouseUp(GraphicsBuilder* builder) {}

void PathSelectionState::paint(GraphicsBuilder* builder, TCanvas* canvas) {
    // Стандартная отрисовка
    builder->paint(canvas, builder->m_settings.drawArea);

    // Отрисовка текущего пути
    canvas->Pen->Color = builder->m_settings.pathColor;
    canvas->Pen->Width = 2;

    // TODO: Реализация отрисовки выбранного пути
}

// Методы управления состояниями
void GraphicsBuilder::setState(std::unique_ptr<State> newState) {
    if (m_currentState) {
        m_currentState->onExitState(this);
    }

    m_currentState = std::move(newState);

    if (m_currentState) {
        m_currentState->onEnterState(this);
    }
}

void GraphicsBuilder::enterPointSelectionMode(std::function<void(const FoundPoint&)> callback) {
    m_pointSelectionCallback = callback;
    setState(std::make_unique<PointSelectionState>());
}

void GraphicsBuilder::enterPathSelectionMode() {
    setState(std::make_unique<PathSelectionState>());
}

void GraphicsBuilder::returnToDefaultState() {
    setState(std::make_unique<DefaultState>());
}

// Модификация существующих методов
void GraphicsBuilder::mouseDown(int x, int y) {
    if (m_currentState) {
        m_currentState->mouseDown(this, x, y);
    }
}

void GraphicsBuilder::mouseMove(int x, int y) {
    if (m_currentState) {
        m_currentState->mouseMove(this, x, y);
    }
}

void GraphicsBuilder::mouseUp() {
    if (m_currentState) {
        m_currentState->mouseUp(this);
    }
}

void GraphicsBuilder::paint(TCanvas* canvas, const TRect& drawArea) {
    m_settings.drawArea = drawArea;
    if (m_currentState) {
        m_currentState->paint(this, canvas);
    }
}

// В конструктор добавить инициализацию состояния
GraphicsBuilder::GraphicsBuilder(const std::vector<DrawOrderer::OrderStruct>& source)
    : m_source(source)
{
    setState(std::make_unique<DefaultState>());
    updateTransformedData();
}
